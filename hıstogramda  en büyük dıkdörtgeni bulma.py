"""
Задача 1. Поле программиста Петра
Условие задачи

Ограничение времени, с	1
Ограничение памяти, МБ	64
Общее число попыток отправки	15

После очередного завершённого проекта программист Пётр решил переехать в деревню и заняться сельским хозяйством. Мелочиться он не стал, поэтому помимо домика в деревне сразу приобрёл несколько идущих подряд параллельных участков поля, расположенных вдоль прямой дороги. Участки были разделены заборами, при этом все заборы начинались от той самой дороги, но заканчивались на разном удалении от неё не доходя до противоположной границы участка.

Петру нужно объединить эти участки. Но так как Пётр перфекционист, он непременно хочет, чтобы получившийся объединённый участок:

1. был прямоугольным;

2. был ограничен дорогой и двумя уже имеющимися заборами (забор необязательно использовать целиком, а вот удлинять забор нельзя);

3. имел наибольшую возможную площадь.

Как и положено разработчику Пётр получает 300к/наносек, поэтому его совсем не беспокоит тот факт, что часть территории окажется неиспользованной.

Пётр хочет отдохнуть, поэтому он попросил вас помочь с нахождением площади такого участка.

Помогите Петру и найдите два забора, которые вместе с дорогой образуют максимальный по площади прямоугольный участок, и выведите эту площадь.

Ширина всех участков одинакова и равна 1.


Входные данные (поступают в стандартный поток ввода)
На вход вашей программе подаётся одна строка, содержащая массив целых чисел length, где length[i] - длина i-ого забора. Иными словами i-ый элемент массива задаёт забор в виде отрезка от (i, 0) до (i, length[i]), где 0 - это дорога.

Причём 0≤length[i]≤10 000, а количество заборов n удовлетворяет условию 2≤n≤100 000.

Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются.


Выходные данные (ожидаются в стандартном потоке вывода)
Одно целое число, максимальная площадь образованного участка.


Пример 1
Ввод:

2 4 3 2 1 4 1
Вывод:

16
В первом примере участок наибольшей площади образуется между двумя заборами длины 4.


Пример 2
Ввод:

1 2
Вывод:

1
В данном примере второй забор используется не на всю длину, т.к. нас интересуют только прямоугольные участки.



Примечания по оформлению решения
Возможно использование только стандартных библиотек языков, установка и использование дополнительных библиотек невозможны.

При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.


Примеры работы со стандартными потоками ввода и вывода
Для JS можно использовать readline и console.log:

const readline = require('readline').createInterface(process.stdin, process.stdout);
readline.on('line', (line) => {
    // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
    ...
    console.log(String(result));
    readline.close();
}).on('close', () => process.exit(0));

в Python можно использовать встроенные функции input() и print():

line = input()
...
print(result)

в Java можно использовать java.util.Scanner и System.out.println:

Scanner in = new Scanner(System.in);
String line = in.nextLine();
...
System.out.println(result);

Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать синтаксические ошибки и ошибки выполнения.


Задачу можно решить, используя подход на основе стека для нахождения максимальной площади прямоугольника под гистограммой.

Решение
Мы можем рассматривать каждый забор как высоту столбца в гистограмме. Задача сводится к поиску максимальной площади прямоугольника, который можно построить, используя один или несколько соседних столбцов.

Алгоритм:
Мы используем стек для хранения индексов заборов, чтобы эффективно находить максимальную площадь.
Проходим по всем заборам:
Если текущий забор выше или равен предыдущему, добавляем его индекс в стек.
Если текущий забор ниже предыдущего, вынимаем из стека индексы до тех пор, пока не встретим более низкий забор, и для каждого вынутого забора вычисляем площадь прямоугольника.
После окончания прохода по заборам нужно также обработать оставшиеся элементы в стеке.
"""


def maxRectangleArea(lengths):
    stack = []
    max_area = 0
    index = 0

    while index < len(lengths):
        # Если текущая высота больше или равна высоте на вершине стека, добавляем её в стек
        if not stack or lengths[index] >= lengths[stack[-1]]:
            stack.append(index)
            index += 1
        else:
            # Вынимаем элемент из стека и считаем площадь
            top_of_stack = stack.pop()
            # Если стек пустой, ширина = index, иначе ширина = index - 1 - stack[-1]
            width = index if not stack else index - stack[-1] - 1
            # Площадь = высота * ширина
            area = lengths[top_of_stack] * width
            max_area = max(max_area, area)

    # Обрабатываем оставшиеся элементы в стеке
    while stack:
        top_of_stack = stack.pop()
        width = index if not stack else index - stack[-1] - 1
        area = lengths[top_of_stack] * width
        max_area = max(max_area, area)

    return max_area


# Чтение входных данных
lengths = list(map(int, input().split()))
# Вывод результата
print(maxRectangleArea(lengths))
